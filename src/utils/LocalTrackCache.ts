/**
 * Utility for loading and processing the local tracks cache file
 * This works with the cache generated by the generate_local_tracks_cache.py script
 */

// Define interfaces for type safety
export interface LocalTrack {
  path: string;
  filename: string;
  track_id: string;
  size: number;
  modified: number;
  artist: string;
  title: string;
}

export interface CacheData {
  generated: string;
  music_directory: string;
  total_files: number;
  files_with_track_id: number;
  tracks: LocalTrack[];
}

export interface MasterTrack {
  uri: string;
  name: string;
  artists: string;
  album: string;
  added_at?: string;
  trackId?: string;
}

// Default cache file path - can be customized in settings
const DEFAULT_CACHE_PATH = "local_tracks_cache.json";

/**
 * Loads the local tracks cache file
 * @param {string} cachePath - Path to the cache file (relative to Spotify's data directory)
 * @returns {Promise<CacheData>} The cached data
 */
export async function loadLocalTracksCache(
  cachePath: string = DEFAULT_CACHE_PATH
): Promise<CacheData> {
  try {
    // First try to load from Spotify cache directory
    let cacheFileContent: string | undefined;

    try {
      // Try using the Spicetify.Platform.getLocalStorageAPI() to access user data directory
      if (Spicetify && Spicetify.Platform) {
        // Use type assertions to bypass TypeScript's type checking
        const fs = (Spicetify.Platform as any).getFileAPI
          ? (Spicetify.Platform as any).getFileAPI()
          : (window as any).fs;

        if (fs && typeof fs.readFile === "function") {
          cacheFileContent = await fs.readFile(cachePath, { encoding: "utf8" });
        }
      }
    } catch (e) {
      console.warn("Could not access cache file through Spicetify API:", e);
    }

    // Fallback: Try to load from web server if we're using a hosted cache
    if (!cacheFileContent) {
      // Assuming the cache is served via HTTP from your local setup
      const response = await fetch(cachePath);
      if (!response.ok) {
        throw new Error(`HTTP error loading cache: ${response.status}`);
      }
      cacheFileContent = await response.text();
    }

    // Parse the JSON data
    const cacheData = JSON.parse(cacheFileContent) as CacheData;

    // Validate the data structure
    if (!cacheData.tracks || !Array.isArray(cacheData.tracks)) {
      throw new Error("Invalid cache file format: missing or invalid tracks array");
    }

    console.log(`Loaded local tracks cache with ${cacheData.tracks.length} tracks`);
    return cacheData;
  } catch (error) {
    console.error("Error loading local tracks cache:", error);
    // Return a valid but empty cache structure to prevent errors
    return {
      generated: new Date().toISOString(),
      music_directory: "",
      total_files: 0,
      files_with_track_id: 0,
      tracks: [],
    };
  }
}

/**
 * Creates a map of track IDs to local track information
 * @param {CacheData} cacheData - The cache data loaded from the cache file
 * @returns {Map<string, LocalTrack>} Map of track IDs to local track information
 */
export function createTrackIdMap(cacheData: CacheData): Map<string, LocalTrack> {
  const trackIdMap = new Map<string, LocalTrack>();

  if (!cacheData || !cacheData.tracks) {
    return trackIdMap;
  }

  for (const track of cacheData.tracks) {
    if (track.track_id) {
      trackIdMap.set(track.track_id, track);
    }
  }

  console.log(`Created track ID map with ${trackIdMap.size} entries`);
  return trackIdMap;
}

/**
 * Finds tracks in the Master playlist that are missing from local files
 * @param {MasterTrack[]} masterTracks - Array of tracks from the Master playlist
 * @param {Map<string, LocalTrack>} localTrackMap - Map of track IDs to local track info
 * @returns {MasterTrack[]} Array of tracks missing from local files
 */
export function findMissingTracks(
  masterTracks: MasterTrack[],
  localTrackMap: Map<string, LocalTrack>
): MasterTrack[] {
  if (!masterTracks || !Array.isArray(masterTracks)) {
    return [];
  }

  const missingTracks: MasterTrack[] = [];

  for (const track of masterTracks) {
    const trackId = track.uri.split(":").pop(); // Extract ID from uri

    if (trackId && !localTrackMap.has(trackId)) {
      missingTracks.push({
        ...track,
        trackId,
      });
    }
  }

  console.log(`Found ${missingTracks.length} tracks missing from local files`);
  return missingTracks;
}

/**
 * Fetches tracks from the Master playlist
 * @returns {Promise<MasterTrack[]>} Array of track objects
 */
export async function fetchMasterPlaylistTracks(): Promise<MasterTrack[]> {
  try {
    // Get the Master playlist ID from settings or environment
    const masterPlaylistId = await getMasterPlaylistId();

    if (!masterPlaylistId) {
      throw new Error("Master playlist ID not configured");
    }

    // Fetch the playlist tracks using Spotify API
    const response = await Spicetify.CosmosAsync.get(
      `https://api.spotify.com/v1/playlists/${masterPlaylistId}/tracks`
    );

    if (!response || !response.items) {
      throw new Error("Invalid response from Spotify API");
    }

    // Extract and format the track data
    const tracks: MasterTrack[] = response.items.map((item: any) => ({
      uri: item.track.uri,
      name: item.track.name,
      artists: item.track.artists.map((a: any) => a.name).join(", "),
      album: item.track.album?.name || "Unknown Album",
      added_at: item.added_at,
    }));

    console.log(`Fetched ${tracks.length} tracks from Master playlist`);
    return tracks;
  } catch (error) {
    console.error("Error fetching Master playlist tracks:", error);
    return [];
  }
}

/**
 * Gets the Master playlist ID from settings
 * @returns {Promise<string|null>} The Master playlist ID
 */
async function getMasterPlaylistId(): Promise<string | null> {
  // First check for settings in localStorage
  const settings = localStorage.getItem("tagify:settings");
  if (settings) {
    try {
      const parsedSettings = JSON.parse(settings);
      if (parsedSettings.masterPlaylistId) {
        return parsedSettings.masterPlaylistId;
      }
    } catch (e) {
      console.warn("Error parsing settings from localStorage:", e);
    }
  }

  // Try to find a playlist named "MASTER"
  try {
    const userPlaylists = await Spicetify.CosmosAsync.get(
      "https://api.spotify.com/v1/me/playlists?limit=50"
    );

    if (userPlaylists && userPlaylists.items) {
      const masterPlaylist = userPlaylists.items.find(
        (p: any) => p.name.toUpperCase() === "MASTER"
      );

      if (masterPlaylist) {
        return masterPlaylist.id;
      }
    }
  } catch (e) {
    console.warn("Error searching for MASTER playlist:", e);
  }

  // If no ID found, provide UI guidance
  console.warn("Master playlist ID not found in settings or by name");
  return null;
}
